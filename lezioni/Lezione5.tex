% ===================================================================
% FILE: Lezione5.tex
% ===================================================================

\part{Lezione 21 (06/11/2025) }

\section{Paradigma Divide et Impera }
Il paradigma "Divide et Impera" (Dividi e Conquista) è una tecnica per progettare algoritmi, tipicamente ricorsivi, che si articola in tre fasi:

\begin{definition}[Paradigma Divide et Impera]
    \begin{enumerate}
        \item \textbf{DIVIDE}: Il problema di dimensione $n$ viene suddiviso in $a$ sottoproblemi dello stesso tipo, ma di dimensione minore ($n/b$).
        \item \textbf{IMPERA}: I sottoproblemi vengono risolti. Se sono abbastanza piccoli (casi base), vengono risolti direttamente. Altrimenti, vengono risolti ricorsivamente con la stessa tecnica.
        \item \textbf{COMBINE}: Le soluzioni degli $a$ sottoproblemi vengono combinate per ottenere la soluzione del problema originale.
    \end{enumerate}
\end{definition}

\subsection{Diagramma Concettuale }
\begin{center}
    \begin{tikzpicture}[
        node distance=2cm and 1.5cm,
        block/.style={draw, rectangle, minimum height=1cm, minimum width=1.5cm, text centered, font=\small},
        dot/.style={node distance=1.5cm and 1cm}
        ]

        \node[block] (P) {$P, n$ (Problema) };
        \node[block] (P1) [below left of=P, yshift=-1cm] {$P_1, n_1$ };
        \node (P_dots) [right=of P1, style=dot] {$\dots$};
        \node[block] (Pa) [right=of P_dots, style=dot] {$P_a, n_a$ };

        \node[block] (S1) [below=of P1] {$S_1, n_1$ };
        \node (S_dots) [right=of S1, style=dot] {$\dots$};
        \node[block] (Sa) [right=of S_dots, style=dot] {$S_a, n_a$ };
        \node[block] (S) [below right of=S_dots, yshift=-1cm] {$S, n$ (Soluzione) };

        \draw[->, thick] (P.south) -- (P1.north) node [midway, left, xshift=-5mm] {\textbf{DIVIDE} };
        \draw[->, thick] (P.south) -- (P_dots.north);
        \draw[->, thick] (P.south) -- (Pa.north);

        \draw[->, thick, decorate, decoration={snake, segment length=8mm, amplitude=1mm}] (P1.south) -- (S1.north) node [midway, left, xshift=-5mm] {\textbf{"IMPERA"} };
        \draw[->, thick, decorate, decoration={snake, segment length=8mm, amplitude=1mm}] (P_dots.south) -- (S_dots.north);
        \draw[->, thick, decorate, decoration={snake, segment length=8mm, amplitude=1mm}] (Pa.south) -- (Sa.north);

        \draw[->, thick] (S1.south) -- (S.west);
        \draw[->, thick] (S_dots.south) -- (S.north);
        \draw[->, thick] (Sa.south) -- (S.east) node [midway, below, xshift=5mm, yshift=-5mm] {\textbf{COMBINE} };
    \end{tikzpicture}
\end{center}

\section{Analisi Complessità D\&I}

\begin{definition}[Analisi Complessità D\&I]
    Sia $T(n)$ il costo per risolvere un problema di dimensione $n$.
    Sia $D(n)$ il costo della fase DIVIDE.
    Sia $C(n)$ il costo della fase COMBINE.
    L'equazione di ricorrenza generale è:
    $$ T(n) = \sum_{i=1}^{a} T(n_i) + D(n) + C(n) $$

    Caso particolare: \textbf{Divisione Bilanciata}.
    Il problema è diviso in $a$ sottoproblemi, ognuno di dimensione $n/b$.
    Sia $f(n) = D(n) + C(n)$ il costo di divide e combine.
    $$ T(n) = aT(n/b) + f(n) $$
\end{definition}


\section{Esempio: Ricerca Binaria (D\&I) }

\begin{example}[Ricerca Binaria: Setup]
    \begin{itemize}
        \item \textbf{Input}: $A[p..r]$ ordinato, chiave $k$.
        \item \textbf{Output}: Indice $i$ t.c. $A[i]=k$, o $-1$.
    \end{itemize}
\end{example}

\begin{algorithmic}[1]
    \Procedure{BinarySearch}{A, p, r, k}
        \If{$p > r$} \Comment{Caso Base 1: array vuoto }
            \State \Return $-1$
        \EndIf

        \State $q = \lfloor (p+r)/2 \rfloor$ \Comment{DIVIDE }

        \If{$A[q] == k$} \Comment{IMPERA (Caso Base 2) }
            \State \Return $q$
        \ElsIf{$A[q] > k$} \Comment{IMPERA (Ricorsione) }
            \State \Return \Call{BinarySearch}{A, p, q-1, k}
        \Else
            \State \Return \Call{BinarySearch}{A, q+1, r, k}
        \EndIf

        \Comment{COMBINE: non necessario, costo $\Theta(1)$ }
    \EndProcedure
\end{algorithmic}

\begin{explanation}{Ricerca Binaria}
Ad ogni passo dimezza lo spazio di ricerca ($n \to n/2 \to n/4 \dots$).
\begin{itemize}
    \item Se $A[q] > k$, cerco a sinistra.
    \item Se $A[q] < k$, cerco a destra.
    \item Costo logaritmico $\Theta(\log n)$.
\end{itemize}
\end{explanation}


\begin{observation}[Analisi: Ricerca Binaria]
    \textbf{Analisi Ricorrenza BS: }
    C'è $a=1$ sottoproblema di dimensione $n/b = n/2$.
    $f(n) = D(n) + C(n) = \Theta(1) + \Theta(1) = \Theta(1)$.
    $$ T(n) = \begin{cases} \Theta(1) & \text{se } n \le 1 \\ T(n/2) + \Theta(1) & \text{se } n > 1 \end{cases} $$

    \textbf{Soluzione (Metodo Iterativo)}:
    $T(n) = T(n/2) + c$
    $T(n) = (T(n/4) + c) + c = T(n/4) + 2c$
    $T(n) = (T(n/8) + c) + 2c = T(n/8) + 3c$
    ... dopo $i$ passi...
    $T(n) = T(n/2^i) + i \cdot c$
    Ci si ferma al caso base quando $n/2^i = 1 \implies i = \log_2 n$.
    $T(n) = T(1) + c \cdot \log_2 n = \Theta(1) + \Theta(\log n) = \Theta(\log n)$.
\end{observation}

\section{Esempio: Minimo/Massimo (D\&I) }

\begin{example}[Minimo/Massimo: Setup]
    \begin{itemize}
        \item \textbf{Input}: $A[1..n]$.
        \item \textbf{Output}: Coppia $\langle min, max \rangle$ di A.
    \end{itemize}
\end{example}

\begin{algorithmic}[1]
    \Procedure{MinMax}{A, p, r}
        \If{$r - p \le 1$} \Comment{Caso Base: 1 o 2 elementi }
            \If{$A[p] \le A[r]$}
                \State \Return $\langle A[p], A[r] \rangle$
            \Else
                \State \Return $\langle A[r], A[p] \rangle$
            \EndIf
        \Else
            \State $q = \lfloor (p+r)/2 \rfloor$ \Comment{DIVIDE}
            \State $\langle min_1, max_1 \rangle = \Call{MinMax}{A, p, q}$ \Comment{IMPERA }
            \State $\langle min_2, max_2 \rangle = \Call{MinMax}{A, q+1, r}$ \Comment{IMPERA }
            \State $min = \min(min_1, min_2)$ \Comment{COMBINE }
            \State $max = \max(max_1, max_2)$
            \State \Return $\langle min, max \rangle$
        \EndIf
    \EndProcedure
\end{algorithmic}

\begin{explanation}{Minimo e Massimo Simultanei}
Per trovare min e max con meno confronti ($3 \lfloor n/2 \rfloor$ invece di $2n$):
\begin{itemize}
    \item Divide l'array in due metà.
    \item Risolve ricorsivamente.
    \item Combina confrontando i minimi tra loro e i massimi tra loro.
\end{itemize}
\end{explanation}


\begin{observation}[Analisi: Minimo/Massimo]
    \textbf{Analisi Ricorrenza MinMax:}
    $a=2$ sottoproblemi, $n/b = n/2$.
    $f(n) = D(n) \text{ (cost.)} + C(n) \text{ (2 confr.)} = \Theta(1)$.
    $$ T(n) = \begin{cases} \Theta(1) & \text{se } n \le 2 \\ 2T(n/2) + \Theta(1) & \text{se } n \ge 3 \end{cases} $$
    (Questa ricorrenza si risolve in $T(n) = \Theta(n)$).
\end{observation}

\newpage
