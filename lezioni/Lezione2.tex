% ===================================================================
% FILE: Lezione2.tex
% ===================================================================

\part{Lezione 2 (16/10/2025) }

\section{Selection Sort (Analisi) }
Pseudocodice (identico a Lez12).
\begin{algorithmic}[1]
    \Procedure{SelectionSort}{A}
        \For{$i = 1 \to n-1$}
            \State $min = i$
            \For{$j = i+1 \to n$} \Comment{Il loop interno fa $(n-i)$ iterazioni }
                \If{$A[j] < A[min]$}
                    \State $min = j$
                \EndIf
            \EndFor
            \State \Call{Swap}{A[i], A[min]}
        \EndFor
    \EndProcedure
\end{algorithmic}

\begin{explanation}{Selection Sort}
L'algoritmo seleziona iterativamente il minimo dalla parte non ordinata e lo sposta alla fine della parte ordinata.
\begin{itemize}
    \item \textbf{Ciclo Esterno}: Avanza il confine tra ordinato e non ordinato.
    \item \textbf{Ciclo Interno}: Cerca il minimo nel sottoarray destro.
    \item \textbf{Swap}: Scambia il minimo trovato con l'elemento corrente.
\end{itemize}
\end{explanation}

\subsection{Analisi Complessità (Numero Confronti) }
Il costo è dominato dal numero di confronti ($A[j] < A[min]$).
Il ciclo esterno \texttt{for i} esegue $n-1$ iterazioni.
Il ciclo interno \texttt{for j} esegue $n-i$ iterazioni per ogni $i$.
Il numero totale di confronti $C(n)$ è:
\[ C(n) = \sum_{i=1}^{n-1} (n-i) \]
\[ C(n) = (n-1) + (n-2) + \dots + 2 + 1 \]
Questa è la somma dei primi $n-1$ numeri naturali.
\[ C(n) = \frac{(n-1)n}{2} = \frac{n^2}{2} - \frac{n}{2} \]

La complessità è \textbf{Quadratica}, $T(n) \in \Theta(n^2)$.
\begin{observation}
    A differenza di Insertion Sort, la complessità di Selection Sort è $\Theta(n^2)$ \emph{sempre}, sia nel caso ottimo, medio e pessimo, perché i cicli \texttt{for} vengono eseguiti sempre lo stesso numero di volte.
\end{observation}

\subsection{Invariante di Ciclo }

\begin{definition}[Invariante: Selection Sort]
    \textbf{Invariante:} All'inizio dell'iterazione $i$-esima del ciclo FOR esterno (per $i=1..n-1$):
    \begin{enumerate}
        \item Il sottoarray $A[1..i-1]$ contiene gli $i-1$ elementi più piccoli di A.
        \item Il sottoarray $A[1..i-1]$ è ordinato.
    \end{enumerate}
    (Si dimostra per induzione ).
\end{definition}

\section{Esercizi}


\begin{example}[Esercizio 1: Cerca A[i] = i (Array non ordinato)]
    \begin{itemize}
        \item \textbf{Input}: Array $A[1..n]$ di interi.
        \item \textbf{Output}: TRUE se $\exists i$ t.c. $A[i] = i$, FALSE altrimenti.
    \end{itemize}

    \begin{algorithmic}[1]
        \Procedure{Cerca-Indice}{A, n}
            \State $i = 1$
            \State $trovato = \text{false}$
            \While{(\textbf{not} $trovato$) \textbf{and} ($i \le n$)}
                \If{$A[i] == i$}
                    \State $trovato = \text{true}$
                \Else
                    \State $i = i + 1$
                \EndIf
            \EndWhile
            \State \Return $trovato$
        \EndProcedure
    \end{algorithmic}

\begin{explanation}{Ricerca Lineare}
Scansiona l'array elemento per elemento.
Se trova $A[i] == i$, si ferma e ritorna TRUE.
Nel caso pessimo (non trovato), scorre tutto l'array ($n$ passi).
\end{explanation}
    \textbf{Analisi:}
    \begin{itemize}
        \item Caso Ottimo: $A[1]=1$. $T(n) \in \Theta(1)$.
        \item Caso Pessimo: Nessun $i$ t.c. $A[i]=i$. $T(n) \in \Theta(n)$ (Lineare).
    \end{itemize}
\end{example}


\begin{example}[Esercizio 2: Cerca A[i] = i (Array ordinato)]
    \begin{itemize}
        \item \textbf{Input}: Array $A[1..n]$ di interi, \textbf{ordinato}.
        \item \textbf{Output}: TRUE se $\exists i$ t.c. $A[i] = i$.
    \end{itemize}
    Si può usare una modifica della Ricerca Binaria.
    Si calcola $q = \lfloor (p+r)/2 \rfloor$.
    \begin{itemize}
        \item Se $A[q] == q$: Trovato.
        \item Se $A[q] > q$: L'elemento $i$ (se esiste) non può essere a destra di $q$. Si cerca a sinistra ($r=q-1$).
        \item Se $A[q] < q$: L'elemento $i$ (se esiste) non può essere a sinistra di $q$. Si cerca a destra ($p=q+1$).
    \end{itemize}
    \textbf{Analisi}: $T(n) \in O(\log n)$.
\end{example}


\begin{example}[Esercizio 3: Cerca A[i] = i (Ordinato, positivi, distinti)]
    \begin{itemize}
        \item \textbf{Input}: Array $A[1..n]$ ordinato, di interi \textbf{positivi} e \textbf{distinti}.
        \item \textbf{Output}: TRUE se $\exists i$ t.c. $A[i] = i$.
    \end{itemize}
    Se $A[1] = 1$: Ritorna TRUE.
    Se $A[1] > 1$: (cioè $A[1] \ge 2$). Allora $A[i] \ge A[1] + (i-1) \ge 2 + i - 1 = i+1$.
    Quindi $A[i] > i$ per ogni $i$. Ritorna FALSE.
    L'algoritmo corretto è:
    \begin{algorithmic}[1]
        \Procedure{Cerca-i-Positivi}{A}
            \State \Return $(A[1] == 1)$
        \EndProcedure
    \end{algorithmic}
    \textbf{Analisi}: $T(n) \in \Theta(1)$ (Costante).
\end{example}

\begin{example}[Esercizio 4: Somma K]
    \begin{itemize}
        \item \textbf{Input}: Array $A[1..n]$ di interi, $k$ intero.
        \item \textbf{Output}: TRUE se $\exists i, j$ t.c. $A[i] + A[j] = k$.
    \end{itemize}
    \textbf{Soluzione 1 (Brute force):}
    \begin{algorithmic}[1]
        \For{$i = 1 \to n-1$}
            \For{$j = i+1 \to n$}
                \If{$A[i] + A[j] == k$}
                    \State \Return $\text{true}$
                \EndIf
            \EndFor
        \EndFor
        \State \Return $\text{false}$
    \end{algorithmic}
    \textbf{Analisi 1}: Caso pessimo $\Theta(n^2)$ (Quadratico).
    \textbf{Soluzione 2 (se $A$ è ordinato ):}
    Si usano due indici, $L=1$ e $R=n$.
    \begin{algorithmic}[1]
        \State $L=1$, $R=n$
        \While{$L < R$}
            \State $somma = A[L] + A[R]$
            \If{$somma == k$}
                \State \Return $\text{true}$
            \ElsIf{$somma < k$}
                \State $L = L + 1$ \Comment{Serve una somma più grande }
            \Else
                \State $R = R - 1$ \Comment{Serve una somma più piccola}
            \EndIf
        \EndWhile
        \State \Return $\text{false}$
    \end{algorithmic}

\begin{explanation}{Tecnica dei Due Indici}
Poiché l'array è ordinato, possiamo restringere la ricerca:
\begin{itemize}
    \item $Somma < K \to$ Incremento $L$ (serve valore più grande).
    \item $Somma > K \to$ Decremento $R$ (serve valore più piccolo).
\end{itemize}
Questo riduce la complessità da quadratica a lineare.
\end{explanation}
    \textbf{Analisi 2}: $T(n) \in \Theta(n)$ (Lineare).
\end{example}


\begin{example}[Esercizio 5: Array Palindromo]
    \begin{itemize}
        \item \textbf{Input}: Array $A[1..n]$.
        \item \textbf{Output}: TRUE se $A$ è palindromo, FALSE altrimenti. (E.g., \texttt{[3, 7, 21, 40, 21, 7, 3]} ).
    \end{itemize}
    \textbf{Soluzione (con due indici):}
    \begin{algorithmic}[1]
        \State $i=1$, $j=n$
        \While{$i < j$}
            \If{$A[i] \neq A[j]$}
                \State \Return $\text{false}$
            \EndIf
            \State $i = i + 1$
            \State $j = j - 1$
        \EndWhile
        \State \Return $\text{true}$
    \end{algorithmic}

\begin{explanation}{Verifica Palindromo}
Confronta gli estremi convergendo verso il centro.
Se una coppia non corrisponde, non è palindromo.
\end{explanation}
    \textbf{Analisi}: $T(n) \in \Theta(n)$.
\end{example}

\newpage
